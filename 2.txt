ѕри зуммировании маркер неправильно указывает координаты - съезжает. „тобы устранить: 
https://stackoverflow.com/questions/65676759/react-leaflet-default-marker-moves-on-zoom
Ќужно создать новую иконку маркера как здесь https://gist.github.com/kboul/881234200f89d6bffd7d584329735637
import L from 'leaflet'

const iconNew = L.icon({
  iconSize: [25, 41],
  iconAnchor: [10, 41],
  popupAnchor: [2, -40],
  iconUrl: "https://unpkg.com/leaflet@1.6/dist/images/marker-icon.png",
  shadowUrl: "https://unpkg.com/leaflet@1.6/dist/images/marker-shadow.png"
});

и добавить пропсом при рендеринге маркера <LeafletMarker position={[51.505, -0.09]} icon={iconNew}>
 или так
<Marker position={position} icon={iconNew} >

==================

„тобы перерисовать карту при получении новых координат, создаем новую функцию с использованием useCallback:
const displayMap = useMemo(
        () => (
            <MapContainer
                center={position}
                zoom={zoom}
                // scrollWheelZoom={true}
                scrollWheelZoom='center'
                ref={setMap}>
                <TileLayer
                    attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                />
                <Marker position={position} icon={iconNew} >
                    <Popup>
                        Current location: {coordinates.lat}, {coordinates.lon}
                    </Popup>
                </Marker>
            </MapContainer>
        ),
        [coordinates],
    )
и рендерим ее в return : {displayMap}

ј чтобы вызвать перерисовку, используем useEffect, в котором через setTimeout инициализируем map.setView(position, 11). ≈сли так не сделать, то map.setView() будет пытатьс€ инициализироватьс€ еще не полученными значени€ми координат, что не позволит нарисовать карту.
ѕеременна€ isLoading устанавливаетс€ в true при загрузке данных с помощью axios.
useEffect(() => {
        const timer = setTimeout(() => {
            map.setView(position, 11);
        }, 50);
        setIsLoading(false);
        return () => clearTimeout(timer);
    }, [isLoading])

==================
